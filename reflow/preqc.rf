param (
    // Pipe-separated, ordered list of read 1 fastq.gz files, same order as ids and read2s
    read1s string

    // Pipe-separated, ordered list of read 2 fastq.gz files, same order as ids and read1s
    read2s string

    // Pipe-separated, ordered list of sample ids
    ids string

    // Full s3 folder location to put preqc json files
    output string

    // Number of threads to use for multithreaded programs
    threads = 16

    // Maximum contig length to extend
    max_contig_length = 1000000
)


sga := "quay.io/biocontainers/sga:0.10.15--hd4ff3c4_3"

val dirs = make("$/dirs")
val utils = make("./utils.rf")
val fastp = make("./fastp.rf")

// Instantiate Go system module "strings"
val strings = make("$/strings")

preprocessed_suffix := "_sga_preprocessed.fastq"

func Preprocess(interleaved file, id string) = {

    // First three lines are renaming nonsense because "kat hist" needs
        // the filename to end in fastq.gz to detect the type
    d := dirs.Make([id+"_interleaved.fastq.gz": interleaved])

    outdir := exec(image := sga, cpu := 1, mem := 32*GiB) (outdir dir) {"
                sga preprocess --pe-mode 1 \
                        --permute-ambiguous \
                        --no-primer-check \
                        {{d}}/{{id}}_interleaved.fastq.gz \
                        > {{outdir}}/{{id}}{{preprocessed_suffix}}
    "}
    val (preprocessed, _) = dirs.Pick(outdir, "*{{preprocessed_suffix}}")
    preprocessed
}


func Index(preproccessed file, id string) = {
	// Outputs a folder with:
	// - {{id}}_sga_preprocessed.bwt
	// - {{id}}_sga_preprocessed.sai

    // First three lines are renaming nonsense because "kat hist" needs
	// the filename to end in fastq.gz to detect the type
    d := dirs.Make([id + preprocessed_suffix: preproccessed])

    exec(image := sga, cpu := threads, mem := 32*GiB) (outdir dir) {"
		sga index -a ropebwt --no-reverse -t {{threads}} {{d}}/{{id}}{{preprocessed_suffix}}
    "}
}

func PreQC(preproccessed file, index dir, id string) = {
	// Outputs a json file

	// Make sure preprocessed file has same name as it was when it was indexed
    d := dirs.Make([id+"_sga_preproccessed.fastq": preproccessed])

    exec(image := sga, cpu := threads, mem := 32*GiB) (output file) {"
    	cd {{index}}
		sga preqc -t {{threads}} --max-contig-length {{max_contig_length}} \
			{{d}}/{{id}}{{preprocessed_suffix}} > {{output}}

    "}
}

func PreQCReport(preqcs [file], ids [string]) = {

    d := dirs.Make(map([(id + ".preqc.json", preqc) | (preqc, id) <- zip(preqcs, ids)]))

    exec(image := sga, cpu := 1, mem := 2*GiB) (output file) {"
    	sga-preqc-report.py {{d}}/*.preqc.json
    "}
}


func RunPreQC(read1s, read2s [file], ids [string]) = {
	interleaved := [fastp.Interleave(r1, r2) | ((r1, r2), id) <- zip(zip(read1s, read2s), ids)]
    preprocessed := [Preprocess(fastq, id) | (fastq, id) <- zip(interleaved, ids)]
	indexed := [Index(f, id) | (f, id) <- zip(preprocessed, ids)]
	preqcs := [PreQC(f, index, id) | (f, (index, id)) <- zip(interleaved, zip(indexed, ids))]

	// Rename files by id
    dirs.Make(map([(id + ".preqc.json", preqc) | (preqc, id) <- zip(preqcs, ids)]))
}


r1s := utils.SplitByPipe(read1s)
r2s := utils.SplitByPipe(read2s)
ids_split := strings.Split(ids, "|")

outdir := RunPreQC(r1s, r2s, ids_split)

@requires(cpu := 1)
val Main = dirs.Copy(outdir, output)