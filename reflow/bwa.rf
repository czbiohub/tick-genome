param (
	threads = 8
)

bwa := "quay.io/biocontainers/bwa:0.7.4--ha92aebf_0"


val dirs = make("$/dirs")

val samtools = make("./samtools.rf")


// bash-4.2#  bwa index

// Usage:   bwa index [-a bwtsw|is] [-c] <in.fasta>

// Options: -a STR    BWT construction algorithm: bwtsw or is [auto]
//          -p STR    prefix of the index [same as fasta name]
//          -6        index files named as <in.fasta>.64.* instead of <in.fasta>.* 

// Warning: `-a bwtsw' does not work for short genomes, while `-a is' and
//          `-a div' do not work not for long genomes. Please choose `-a'
//          according to the length of the genome.
func Index(fasta_gz file, id string) = {
	// Create a bwt index of the fasta

    // BWA accepts gzipped files as input
    outdir := exec(image := bwa, cpu := 1) (outdir dir) {"
        # Ignore failures here. The file from 1000genomes has a trailer
        # that isn't recognized by gunzip. (This is not recommended practice!)
        gunzip -c {{fasta_gz}} > {{outdir}}/{{id}}.fa || true
        cd {{outdir}}
        # use algorithm 'bwtsw' for long genomes with -a bwtsw
        bwa index -a bwtsw {{id}}.fa
	"}
    // NOTE: outdir is not being used anywhere, so it wont get evaluated
    outdir := trace(outdir)
    d := trace(d)
    
    outdir
}

// g1kv37 is the 1000genomes version of hg19.
val g1kv37 = file("s3://1000genomes/technical/reference/human_g1k_v37.fasta.gz")

// g1kv37Indexed is the BWA-indexed version of g1kv37.
val g1kv37Indexed = exec(image := "biocontainers/bwa", mem := GiB, cpu := 1) (out dir) {"
    # Ignore failures here. The file from 1000genomes has a trailer
    # that isn't recognized by gunzip. (This is not recommended practice!)
    gunzip -c {{g1kv37}} > {{out}}/g1k_v37.fa || true
    cd {{out}}
    bwa index -a bwtsw g1k_v37.fa
"}



// bash-4.2# bwa mem -h
// mem: invalid option -- 'h'

// Usage: bwa mem [options] <idxbase> <in1.fq> [in2.fq]

// Algorithm options:

//        -t INT     number of threads [1]
//        -k INT     minimum seed length [19]
//        -w INT     band width for banded alignment [100]
//        -d INT     off-diagonal X-dropoff [100]
//        -r FLOAT   look for internal seeds inside a seed longer than {-k} * FLOAT [1.5]
//        -c INT     skip seeds with more than INT occurrences [10000]
//        -S         skip mate rescue
//        -P         skip pairing; mate rescue performed unless -S also in use
//        -A INT     score for a sequence match [1]
//        -B INT     penalty for a mismatch [4]
//        -O INT     gap open penalty [6]
//        -E INT     gap extension penalty; a gap of size k cost {-O} + {-E}*k [1]
//        -L INT     penalty for clipping [5]
//        -U INT     penalty for an unpaired read pair [17]

// Input/output options:

//        -p         first query file consists of interleaved paired-end sequences
//        -R STR     read group header line such as '@RG\tID:foo\tSM:bar' [null]

//        -v INT     verbose level: 1=error, 2=warning, 3=message, 4+=debugging [3]
//        -T INT     minimum score to output [30]
//        -a         output all alignments for SE or unpaired PE
//        -C         append FASTA/FASTQ comment to SAM output
//        -H         hard clipping
//        -M         mark shorter split hits as secondary (for Picard/GATK compatibility)

// Note: Please read the man page for detailed description of the command line and options.
func Mem(r1, r2 file, id string, 
        index dir, index_name string) = {
    // Run BWA-MEM to align reads to reference
    d := dirs.Make(["R1.fastq.gz": r1, "R2.fastq.gz": r2])

    exec(image := bwa, cpu := threads, mem := 120*GiB) (output file) {"
        cd {{index}}
        bwa mem -M -t {{threads}} \
            {{index_name}} \
            {{d}}/R1.fastq.gz \
            {{d}}/R2.fastq.gz > {{output}}
    "}
}


func Align(r1, r2 file, id string, fasta file, ref_id string) = {
    // Run BWA-MEM to align reads to reference, return sorted bam

    // Create an index of the fasta if it hasn't been created already
    index := Index(fasta, ref_id)

    sam := Mem(r1, r2, id, index, ref_id)
    bam_unsorted := samtools.SamToBam(sam, false)

    // Return sorted bam file
    bam := samtools.SortByCoordinates(bam_unsorted)
    bai := samtools.Index(bam)
    flagstat := samtools.Flagstat(bam)

    prefix := id + "_" + ref_id

    items := [prefix + ".bai": bai, prefix + ".bam": bam,
              prefix + ".flagstat": flagstat]
    dirs.Make(items)
}
